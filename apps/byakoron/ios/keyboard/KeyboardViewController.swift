//
//  KeyboardViewController.swift
//  keyboard
//
//  Created by Nurul Huda (Apon) on 30/3/25.
//

import KeyboardKit
import SwiftUI

class KeyboardViewController: KeyboardInputViewController {
    /// This function is called when the controller launches.
    ///
    /// Call `setup(for:)` to set up this controller for the
    /// `.keyboardKitDemo` application.
    override func viewDidLoad() {

        /// üí° Always call `super.viewDidLoad()`.
        super.viewDidLoad()

        /// ‚ÄºÔ∏è Set up the keyboard for `.keyboardKitDemo`.
        setup(for: .keyboardKitDemo) { [weak self] _ in
            guard let self else { return }
            self.services.actionHandler = CustomActionHandler(controller: self)
        }
        /// üí° Make basic state & service customizations.
        setupDemoServices()
        setupDemoState()
    }

    /// This function is called when the controller needs to
    /// create or update the keyboard view.
    ///
    /// Call `setupKeyboardView(_:)` here to set up a custom
    /// keyboard view or customize the default `KeyboardView`.
    override func viewWillSetupKeyboardView() {
        /// üí° Don't call `super.viewWillSetupKeyboardView()`.
        // super.viewWillSetupKeyboardView()

        /// üí° Call `setupKeyboardView(...)` to customize or
        /// replace the standard `KeyboardView`.
        ///
        /// Return `$0.view` to return the standard view, or
        /// return a custom view for the provided parameters.
        setupKeyboardView { controller in
            KeyboardView(
                state: controller.state,
                services: controller.services,
                buttonContent: { $0.view },
                buttonView: { $0.view },
                collapsedView: { $0.view },
                emojiKeyboard: { $0.view },
                toolbar: { _ in
                    Keyboard.Toolbar {
                        HStack {
                            Spacer()
                            Text("Byakoron - Bengali Keyboard")
                            Spacer()
                        }
                    }
                }
            )
            // .autocorrectionDisabled()
            // .keyboardToolbarStyle(.init(backgroundColor: .red))
        }
    }
}

extension KeyboardViewController {

    /// Make demo-specific changes to your keyboard services.
    fileprivate func setupDemoServices() {

        /// üí° You can replace any service with a custom service.
        services.autocompleteService = services.autocompleteService
    }

    /// Make demo-specific changes to your keyboard's state.
    fileprivate func setupDemoState() {

        /// üí° This enable more locales.
        state.keyboardContext.locales = [.english, .spanish]

        /// üí° This overrides the standard enabled locales.
        state.keyboardContext.settings.addedLocales = [.init(.english), .init(.spanish)]

        /// üí° Dock the keyboard to any horizontal edge.
        // state.keyboardContext.settings.keyboardDockEdge = .leading

        /// üí° Configure the space key's long press behavior and trailing action.
        state.keyboardContext.settings.spaceLongPressBehavior = .moveInputCursor
        // state.keyboardContext.settings.spaceContextMenuLeading = .locale
        state.keyboardContext.settings.spaceContextMenuTrailing = .locale

        /// üí° Customize keyboard feedback.
        // state.feedbackContext.settings.isAudioFeedbackEnabled = false
        // state.feedbackContext.settings.isHapticFeedbackEnabled = false
    }
}

extension KeyboardApp {

    static var keyboardKitDemo: KeyboardApp {
        .init(
            name: "Byakoron",
            //            licenseKey: "your-key-here",                // Required by KeyboardKit Pro!
            appGroupId: "group.com.keyboardkit.demo",  // Sets up App Group data sync\
            locales: .keyboardKitSupported  // Sets up the enabled locales
                //            autocomplete: .init(                        // Sets up custom autocomplete
                //                nextWordPredictionRequest: .claude(...) // Sets up AI-based prediction
                //            ),
                //            deepLinks: .init(app: "kkdemo://", ...)     // Defines how to open the app
        )
    }
}

class CustomKeyboardStyleService: KeyboardStyle.StandardStyleService {

    override func buttonStyle(
        for action: KeyboardAction,
        isPressed: Bool
    ) -> Keyboard.ButtonStyle {
        var style = super.buttonStyle(for: action, isPressed: isPressed)
        if !action.isInputAction { return style }
        style.backgroundColor = .red
        return style
    }
}

// Implement transliteration engine using KeyboardKit action handler
class CustomActionHandler: KeyboardAction.StandardActionHandler {

    // Store current input buffer for transliteration
    private var currentInput: String = ""
    
    open override func handle(
        _ gesture: Keyboard.Gesture,
        on action: KeyboardAction
    ) {
        // We only handle press gestures
        guard gesture == .press else {
            super.handle(gesture, on: action)
            return
        }

        // Handle character input
        if action.isCharacterAction {
            // Get the input character
            guard let inputChar = action.inputCalloutText else {
                print("Warning: Could not get character from action \(action)")
                super.handle(gesture, on: action)
                return
            }
            
            // Add to buffer and let the character appear normally
            currentInput += inputChar
            super.handle(gesture, on: action)
            return
        }
        
        // Handle space - this is where we'll do the transliteration
        if action == .space {
            if !currentInput.isEmpty {
                // Get the transliterated text
                let transliterated = transliterate(text: currentInput, mode: "avro")
                
                // Delete the untransliterated text
                for _ in 0..<currentInput.count {
                    keyboardContext.textDocumentProxy.deleteBackward()
                }
                
                // Insert the transliterated text
                keyboardContext.textDocumentProxy.insertText(transliterated)
                
                // Reset the buffer
                currentInput = ""
            }
            
            // Insert the space
            super.handle(gesture, on: action)
            return
        }
        
        // Handle backspace
        if action == .backspace && !currentInput.isEmpty {
            currentInput = String(currentInput.dropLast())
            super.handle(gesture, on: action)
            return
        }
        
        // For any other action (newline, emoji, etc), clear the buffer
        if !currentInput.isEmpty {
            currentInput = ""
        }
        
        // Let the standard handler deal with it
        super.handle(gesture, on: action)
    }
}

func transliterate(text: String, mode: String = "avro") -> String {
    let patterns: [[String: Any]] = [
        ["find": "bhl", "replace": "‡¶≠‡ßç‡¶≤"],
        ["find": "psh", "replace": "‡¶™‡¶∂"],
        ["find": "bdh", "replace": "‡¶¨‡ßç‡¶ß"],
        ["find": "bj", "replace": "‡¶¨‡ßç‡¶ú"],
        ["find": "bd", "replace": "‡¶¨‡ßç‡¶¶"],
        ["find": "bb", "replace": "‡¶¨‡ßç‡¶¨"],
        ["find": "bl", "replace": "‡¶¨‡ßç‡¶≤"],
        ["find": "bh", "replace": "‡¶≠"],
        ["find": "vl", "replace": "‡¶≠‡ßç‡¶≤"],
        ["find": "b", "replace": "‡¶¨"],
        ["find": "v", "replace": "‡¶≠"],
        ["find": "cNG", "replace": "‡¶ö‡ßç‡¶û"],
        ["find": "cch", "replace": "‡¶ö‡ßç‡¶õ"],
        ["find": "cc", "replace": "‡¶ö‡ßç‡¶ö"],
        ["find": "ch", "replace": "‡¶õ"],
        ["find": "c", "replace": "‡¶ö"],
        ["find": "dhn", "replace": "‡¶ß‡ßç‡¶®"],
        ["find": "dhm", "replace": "‡¶ß‡ßç‡¶Æ"],
        ["find": "dgh", "replace": "‡¶¶‡ßç‡¶ò"],
        ["find": "ddh", "replace": "‡¶¶‡ßç‡¶ß"],
        ["find": "dbh", "replace": "‡¶¶‡ßç‡¶≠"],
        ["find": "dv", "replace": "‡¶¶‡ßç‡¶≠"],
        ["find": "dm", "replace": "‡¶¶‡ßç‡¶Æ"],
        ["find": "DD", "replace": "‡¶°‡ßç‡¶°"],
        ["find": "Dh", "replace": "‡¶¢"],
        ["find": "dh", "replace": "‡¶ß"],
        ["find": "dg", "replace": "‡¶¶‡ßç‡¶ó"],
        ["find": "dd", "replace": "‡¶¶‡ßç‡¶¶"],
        ["find": "D", "replace": "‡¶°"],
        ["find": "d", "replace": "‡¶¶"],
        ["find": "...", "replace": "..."],
        ["find": ".`", "replace": "."],
        ["find": "..", "replace": "‡•§‡••"],
        ["find": ".", "replace": "‡•§"],
        ["find": "ghn", "replace": "‡¶ò‡ßç‡¶®"],
        ["find": "Ghn", "replace": "‡¶ò‡ßç‡¶®"],
        ["find": "gdh", "replace": "‡¶ó‡ßç‡¶ß"],
        ["find": "Gdh", "replace": "‡¶ó‡ßç‡¶ß"],
        ["find": "gN", "replace": "‡¶ó‡ßç‡¶£"],
        ["find": "GN", "replace": "‡¶ó‡ßç‡¶£"],
        ["find": "gn", "replace": "‡¶ó‡ßç‡¶®"],
        ["find": "Gn", "replace": "‡¶ó‡ßç‡¶®"],
        ["find": "gm", "replace": "‡¶ó‡ßç‡¶Æ"],
        ["find": "Gm", "replace": "‡¶ó‡ßç‡¶Æ"],
        ["find": "gl", "replace": "‡¶ó‡ßç‡¶≤"],
        ["find": "Gl", "replace": "‡¶ó‡ßç‡¶≤"],
        ["find": "gg", "replace": "‡¶ú‡ßç‡¶û"],
        ["find": "GG", "replace": "‡¶ú‡ßç‡¶û"],
        ["find": "Gg", "replace": "‡¶ú‡ßç‡¶û"],
        ["find": "gG", "replace": "‡¶ú‡ßç‡¶û"],
        ["find": "gh", "replace": "‡¶ò"],
        ["find": "Gh", "replace": "‡¶ò"],
        ["find": "g", "replace": "‡¶ó"],
        ["find": "G", "replace": "‡¶ó"],
        ["find": "hN", "replace": "‡¶π‡ßç‡¶£"],
        ["find": "hn", "replace": "‡¶π‡ßç‡¶®"],
        ["find": "hm", "replace": "‡¶π‡ßç‡¶Æ"],
        ["find": "hl", "replace": "‡¶π‡ßç‡¶≤"],
        ["find": "h", "replace": "‡¶π"],
        ["find": "jjh", "replace": "‡¶ú‡ßç‡¶ù"],
        ["find": "jNG", "replace": "‡¶ú‡ßç‡¶û"],
        ["find": "jh", "replace": "‡¶ù"],
        ["find": "jj", "replace": "‡¶ú‡ßç‡¶ú"],
        ["find": "j", "replace": "‡¶ú"],
        ["find": "J", "replace": "‡¶ú"],
        ["find": "kkhN", "replace": "‡¶ï‡ßç‡¶∑‡ßç‡¶£"],
        ["find": "kShN", "replace": "‡¶ï‡ßç‡¶∑‡ßç‡¶£"],
        ["find": "kkhm", "replace": "‡¶ï‡ßç‡¶∑‡ßç‡¶Æ"],
        ["find": "kShm", "replace": "‡¶ï‡ßç‡¶∑‡ßç‡¶Æ"],
        ["find": "kxN", "replace": "‡¶ï‡ßç‡¶∑‡ßç‡¶£"],
        ["find": "kxm", "replace": "‡¶ï‡ßç‡¶∑‡ßç‡¶Æ"],
        ["find": "kkh", "replace": "‡¶ï‡ßç‡¶∑"],
        ["find": "kSh", "replace": "‡¶ï‡ßç‡¶∑"],
        ["find": "ksh", "replace": "‡¶ï‡¶∂"],
        ["find": "kx", "replace": "‡¶ï‡ßç‡¶∑"],
        ["find": "kk", "replace": "‡¶ï‡ßç‡¶ï"],
        ["find": "kT", "replace": "‡¶ï‡ßç‡¶ü"],
        ["find": "kt", "replace": "‡¶ï‡ßç‡¶§"],
        ["find": "kl", "replace": "‡¶ï‡ßç‡¶≤"],
        ["find": "ks", "replace": "‡¶ï‡ßç‡¶∏"],
        ["find": "kh", "replace": "‡¶ñ"],
        ["find": "k", "replace": "‡¶ï"],
        ["find": "lbh", "replace": "‡¶≤‡ßç‡¶≠"],
        ["find": "ldh", "replace": "‡¶≤‡ßç‡¶ß"],
        ["find": "lkh", "replace": "‡¶≤‡¶ñ"],
        ["find": "lgh", "replace": "‡¶≤‡¶ò"],
        ["find": "lph", "replace": "‡¶≤‡¶´"],
        ["find": "lk", "replace": "‡¶≤‡ßç‡¶ï"],
        ["find": "lg", "replace": "‡¶≤‡ßç‡¶ó"],
        ["find": "lT", "replace": "‡¶≤‡ßç‡¶ü"],
        ["find": "lD", "replace": "‡¶≤‡ßç‡¶°"],
        ["find": "lp", "replace": "‡¶≤‡ßç‡¶™"],
        ["find": "lv", "replace": "‡¶≤‡ßç‡¶≠"],
        ["find": "lm", "replace": "‡¶≤‡ßç‡¶Æ"],
        ["find": "ll", "replace": "‡¶≤‡ßç‡¶≤"],
        ["find": "lb", "replace": "‡¶≤‡ßç‡¶¨"],
        ["find": "l", "replace": "‡¶≤"],
        ["find": "mth", "replace": "‡¶Æ‡ßç‡¶•"],
        ["find": "mph", "replace": "‡¶Æ‡ßç‡¶´"],
        ["find": "mbh", "replace": "‡¶Æ‡ßç‡¶≠"],
        ["find": "mpl", "replace": "‡¶Æ‡¶™‡ßç‡¶≤"],
        ["find": "mn", "replace": "‡¶Æ‡ßç‡¶®"],
        ["find": "mp", "replace": "‡¶Æ‡ßç‡¶™"],
        ["find": "mv", "replace": "‡¶Æ‡ßç‡¶≠"],
        ["find": "mm", "replace": "‡¶Æ‡ßç‡¶Æ"],
        ["find": "ml", "replace": "‡¶Æ‡ßç‡¶≤"],
        ["find": "mb", "replace": "‡¶Æ‡ßç‡¶¨"],
        ["find": "mf", "replace": "‡¶Æ‡ßç‡¶´"],
        ["find": "m", "replace": "‡¶Æ"],
        ["find": "0", "replace": "‡ß¶"],
        ["find": "1", "replace": "‡ßß"],
        ["find": "2", "replace": "‡ß®"],
        ["find": "3", "replace": "‡ß©"],
        ["find": "4", "replace": "‡ß™"],
        ["find": "5", "replace": "‡ß´"],
        ["find": "6", "replace": "‡ß¨"],
        ["find": "7", "replace": "‡ß≠"],
        ["find": "8", "replace": "‡ßÆ"],
        ["find": "9", "replace": "‡ßØ"],
        ["find": "NgkSh", "replace": "‡¶ô‡ßç‡¶ï‡ßç‡¶∑"],
        ["find": "Ngkkh", "replace": "‡¶ô‡ßç‡¶ï‡ßç‡¶∑"],
        ["find": "NGch", "replace": "‡¶û‡ßç‡¶õ"],
        ["find": "Nggh", "replace": "‡¶ô‡ßç‡¶ò"],
        ["find": "Ngkh", "replace": "‡¶ô‡ßç‡¶ñ"],
        ["find": "NGjh", "replace": "‡¶û‡ßç‡¶ù"],
        ["find": "ngOU", "replace": "‡¶ô‡ßç‡¶ó‡ßå"],
        ["find": "ngOI", "replace": "‡¶ô‡ßç‡¶ó‡ßà"],
        ["find": "Ngkx", "replace": "‡¶ô‡ßç‡¶ï‡ßç‡¶∑"],
        ["find": "NGc", "replace": "‡¶û‡ßç‡¶ö"],
        ["find": "nch", "replace": "‡¶û‡ßç‡¶õ"],
        ["find": "njh", "replace": "‡¶û‡ßç‡¶ù"],
        ["find": "ngh", "replace": "‡¶ô‡ßç‡¶ò"],
        ["find": "Ngk", "replace": "‡¶ô‡ßç‡¶ï"],
        ["find": "Ngx", "replace": "‡¶ô‡ßç‡¶∑"],
        ["find": "Ngg", "replace": "‡¶ô‡ßç‡¶ó"],
        ["find": "Ngm", "replace": "‡¶ô‡ßç‡¶Æ"],
        ["find": "NGj", "replace": "‡¶û‡ßç‡¶ú"],
        ["find": "ndh", "replace": "‡¶®‡ßç‡¶ß"],
        ["find": "nTh", "replace": "‡¶®‡ßç‡¶†"],
        ["find": "NTh", "replace": "‡¶£‡ßç‡¶†"],
        ["find": "nth", "replace": "‡¶®‡ßç‡¶•"],
        ["find": "nkh", "replace": "‡¶ô‡ßç‡¶ñ"],
        ["find": "ngo", "replace": "‡¶ô‡ßç‡¶ó"],
        ["find": "nga", "replace": "‡¶ô‡ßç‡¶ó‡¶æ"],
        ["find": "ngi", "replace": "‡¶ô‡ßç‡¶ó‡¶ø"],
        ["find": "ngI", "replace": "‡¶ô‡ßç‡¶ó‡ßÄ"],
        ["find": "ngu", "replace": "‡¶ô‡ßç‡¶ó‡ßÅ"],
        ["find": "ngU", "replace": "‡¶ô‡ßç‡¶ó‡ßÇ"],
        ["find": "nge", "replace": "‡¶ô‡ßç‡¶ó‡ßá"],
        ["find": "ngO", "replace": "‡¶ô‡ßç‡¶ó‡ßã"],
        ["find": "NDh", "replace": "‡¶£‡ßç‡¶¢"],
        ["find": "nsh", "replace": "‡¶®‡¶∂"],
        ["find": "Ngr", "replace": "‡¶ô‡¶∞"],
        ["find": "NGr", "replace": "‡¶û‡¶∞"],
        ["find": "ngr", "replace": "‡¶Ç‡¶∞"],
        ["find": "nj", "replace": "‡¶û‡ßç‡¶ú"],
        ["find": "Ng", "replace": "‡¶ô"],
        ["find": "NG", "replace": "‡¶û"],
        ["find": "nk", "replace": "‡¶ô‡ßç‡¶ï"],
        ["find": "ng", "replace": "‡¶Ç"],
        ["find": "nn", "replace": "‡¶®‡ßç‡¶®"],
        ["find": "NN", "replace": "‡¶£‡ßç‡¶£"],
        ["find": "Nn", "replace": "‡¶£‡ßç‡¶®"],
        ["find": "nm", "replace": "‡¶®‡ßç‡¶Æ"],
        ["find": "Nm", "replace": "‡¶£‡ßç‡¶Æ"],
        ["find": "nd", "replace": "‡¶®‡ßç‡¶¶"],
        ["find": "nT", "replace": "‡¶®‡ßç‡¶ü"],
        ["find": "NT", "replace": "‡¶£‡ßç‡¶ü"],
        ["find": "nD", "replace": "‡¶®‡ßç‡¶°"],
        ["find": "ND", "replace": "‡¶£‡ßç‡¶°"],
        ["find": "nt", "replace": "‡¶®‡ßç‡¶§"],
        ["find": "ns", "replace": "‡¶®‡ßç‡¶∏"],
        ["find": "nc", "replace": "‡¶û‡ßç‡¶ö"],
        ["find": "n", "replace": "‡¶®"],
        ["find": "N", "replace": "‡¶£"],
        ["find": "OI`", "replace": "‡ßà"],
        ["find": "OU`", "replace": "‡ßå"],
        ["find": "O`", "replace": "‡ßã"],
        ["find": "OI", "replace": "‡ßà", "rules": [["matches": [["type": "prefix", "scope": "!consonant"]], "replace": "‡¶ê"], ["matches": [["type": "prefix", "scope": "punctuation"]], "replace": "‡¶ê"]]],
        ["find": "OU", "replace": "‡ßå", "rules": [["matches": [["type": "prefix", "scope": "!consonant"]], "replace": "‡¶î"], ["matches": [["type": "prefix", "scope": "punctuation"]], "replace": "‡¶î"]]],
        ["find": "O", "replace": "‡ßã", "rules": [["matches": [["type": "prefix", "scope": "!consonant"]], "replace": "‡¶ì"], ["matches": [["type": "prefix", "scope": "punctuation"]], "replace": "‡¶ì"]]],
        ["find": "phl", "replace": "‡¶´‡ßç‡¶≤"],
        ["find": "pT", "replace": "‡¶™‡ßç‡¶ü"],
        ["find": "pt", "replace": "‡¶™‡ßç‡¶§"],
        ["find": "pn", "replace": "‡¶™‡ßç‡¶®"],
        ["find": "pp", "replace": "‡¶™‡ßç‡¶™"],
        ["find": "pl", "replace": "‡¶™‡ßç‡¶≤"],
        ["find": "ps", "replace": "‡¶™‡ßç‡¶∏"],
        ["find": "ph", "replace": "‡¶´"],
        ["find": "fl", "replace": "‡¶´‡ßç‡¶≤"],
        ["find": "f", "replace": "‡¶´"],
        ["find": "p", "replace": "‡¶™"],
        ["find": "rri`", "replace": "‡ßÉ"],
        ["find": "rri", "replace": "‡ßÉ", "rules": [["matches": [["type": "prefix", "scope": "!consonant"]], "replace": "‡¶ã"], ["matches": [["type": "prefix", "scope": "punctuation"]], "replace": "‡¶ã"]]],
        ["find": "rrZ", "replace": "‡¶∞‡¶∞‚Äç‡ßç‡¶Ø"],
        ["find": "rry", "replace": "‡¶∞‡¶∞‚Äç‡ßç‡¶Ø"],
        ["find": "rZ", "replace": "‡¶∞‚Äç‡ßç‡¶Ø", "rules": [["matches": [["type": "prefix", "scope": "consonant"], ["type": "prefix", "scope": "!exact", "value": "r"], ["type": "prefix", "scope": "!exact", "value": "y"], ["type": "prefix", "scope": "!exact", "value": "w"], ["type": "prefix", "scope": "!exact", "value": "x"]], "replace": "‡ßç‡¶∞‡ßç‡¶Ø"]]],
        ["find": "ry", "replace": "‡¶∞‚Äç‡ßç‡¶Ø", "rules": [["matches": [["type": "prefix", "scope": "consonant"], ["type": "prefix", "scope": "!exact", "value": "r"], ["type": "prefix", "scope": "!exact", "value": "y"], ["type": "prefix", "scope": "!exact", "value": "w"], ["type": "prefix", "scope": "!exact", "value": "x"]], "replace": "‡ßç‡¶∞‡ßç‡¶Ø"]]],
        ["find": "rr", "replace": "‡¶∞‡¶∞", "rules": [["matches": [["type": "prefix", "scope": "!consonant"], ["type": "suffix", "scope": "!vowel"], ["type": "suffix", "scope": "!exact", "value": "r"], ["type": "suffix", "scope": "!punctuation"]], "replace": "‡¶∞‡ßç"], ["matches": [["type": "prefix", "scope": "consonant"], ["type": "prefix", "scope": "!exact", "value": "r"]], "replace": "‡ßç‡¶∞‡¶∞"]]],
        ["find": "Rg", "replace": "‡¶°‡¶º‡ßç‡¶ó"],
        ["find": "Rh", "replace": "‡¶¢‡¶º"],
        ["find": "R", "replace": "‡¶°‡¶º"],
        ["find": "r", "replace": "‡¶∞", "rules": [["matches": [["type": "prefix", "scope": "consonant"], ["type": "prefix", "scope": "!exact", "value": "r"], ["type": "prefix", "scope": "!exact", "value": "y"], ["type": "prefix", "scope": "!exact", "value": "w"], ["type": "prefix", "scope": "!exact", "value": "x"], ["type": "prefix", "scope": "!exact", "value": "Z"]], "replace": "‡ßç‡¶∞"]]],
        ["find": "shch", "replace": "‡¶∂‡ßç‡¶õ"],
        ["find": "ShTh", "replace": "‡¶∑‡ßç‡¶†"],
        ["find": "Shph", "replace": "‡¶∑‡ßç‡¶´"],
        ["find": "Sch", "replace": "‡¶∂‡ßç‡¶õ"],
        ["find": "skl", "replace": "‡¶∏‡ßç‡¶ï‡ßç‡¶≤"],
        ["find": "skh", "replace": "‡¶∏‡ßç‡¶ñ"],
        ["find": "sth", "replace": "‡¶∏‡ßç‡¶•"],
        ["find": "sph", "replace": "‡¶∏‡ßç‡¶´"],
        ["find": "shc", "replace": "‡¶∂‡ßç‡¶ö"],
        ["find": "sht", "replace": "‡¶∂‡ßç‡¶§"],
        ["find": "shn", "replace": "‡¶∂‡ßç‡¶®"],
        ["find": "shm", "replace": "‡¶∂‡ßç‡¶Æ"],
        ["find": "shl", "replace": "‡¶∂‡ßç‡¶≤"],
        ["find": "Shk", "replace": "‡¶∑‡ßç‡¶ï"],
        ["find": "ShT", "replace": "‡¶∑‡ßç‡¶ü"],
        ["find": "ShN", "replace": "‡¶∑‡ßç‡¶£"],
        ["find": "Shp", "replace": "‡¶∑‡ßç‡¶™"],
        ["find": "Shf", "replace": "‡¶∑‡ßç‡¶´"],
        ["find": "Shm", "replace": "‡¶∑‡ßç‡¶Æ"],
        ["find": "spl", "replace": "‡¶∏‡ßç‡¶™‡ßç‡¶≤"],
        ["find": "sk", "replace": "‡¶∏‡ßç‡¶ï"],
        ["find": "Sc", "replace": "‡¶∂‡ßç‡¶ö"],
        ["find": "sT", "replace": "‡¶∏‡ßç‡¶ü"],
        ["find": "st", "replace": "‡¶∏‡ßç‡¶§"],
        ["find": "sn", "replace": "‡¶∏‡ßç‡¶®"],
        ["find": "sp", "replace": "‡¶∏‡ßç‡¶™"],
        ["find": "sf", "replace": "‡¶∏‡ßç‡¶´"],
        ["find": "sm", "replace": "‡¶∏‡ßç‡¶Æ"],
        ["find": "sl", "replace": "‡¶∏‡ßç‡¶≤"],
        ["find": "sh", "replace": "‡¶∂"],
        ["find": "Sc", "replace": "‡¶∂‡ßç‡¶ö"],
        ["find": "St", "replace": "‡¶∂‡ßç‡¶§"],
        ["find": "Sn", "replace": "‡¶∂‡ßç‡¶®"],
        ["find": "Sm", "replace": "‡¶∂‡ßç‡¶Æ"],
        ["find": "Sl", "replace": "‡¶∂‡ßç‡¶≤"],
        ["find": "Sh", "replace": "‡¶∑"],
        ["find": "s", "replace": "‡¶∏"],
        ["find": "S", "replace": "‡¶∂"],
        ["find": "oo`", "replace": "‡ßÅ"],
        ["find": "oo", "replace": "‡ßÅ", "rules": [["matches": [["type": "prefix", "scope": "!consonant"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶â"], ["matches": [["type": "prefix", "scope": "punctuation"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶â"]]],
        ["find": "o`", "replace": ""],
        ["find": "oZ", "replace": "‡¶Ö‡ßç‡¶Ø"],
        ["find": "o", "replace": "", "rules": [["matches": [["type": "prefix", "scope": "vowel"], ["type": "prefix", "scope": "!exact", "value": "o"]], "replace": "‡¶ì"], ["matches": [["type": "prefix", "scope": "vowel"], ["type": "prefix", "scope": "exact", "value": "o"]], "replace": "‡¶Ö"], ["matches": [["type": "prefix", "scope": "punctuation"]], "replace": "‡¶Ö"]]],
        ["find": "tth", "replace": "‡¶§‡ßç‡¶•"],
        ["find": "t``", "replace": "‡ßé"],
        ["find": "TT", "replace": "‡¶ü‡ßç‡¶ü"],
        ["find": "Tm", "replace": "‡¶ü‡ßç‡¶Æ"],
        ["find": "Th", "replace": "‡¶†"],
        ["find": "tn", "replace": "‡¶§‡ßç‡¶®"],
        ["find": "tm", "replace": "‡¶§‡ßç‡¶Æ"],
        ["find": "th", "replace": "‡¶•"],
        ["find": "tt", "replace": "‡¶§‡ßç‡¶§"],
        ["find": "T", "replace": "‡¶ü"],
        ["find": "t", "replace": "‡¶§"],
        ["find": "aZ", "replace": "‡¶Ö‡ßç‡¶Ø‡¶æ"],
        ["find": "AZ", "replace": "‡¶Ö‡ßç‡¶Ø‡¶æ"],
        ["find": "a`", "replace": "‡¶æ"],
        ["find": "A`", "replace": "‡¶æ"],
        ["find": "a", "replace": "‡¶æ", "rules": [["matches": [["type": "prefix", "scope": "punctuation"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶Ü"], ["matches": [["type": "prefix", "scope": "!consonant"], ["type": "prefix", "scope": "!exact", "value": "a"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶Ø‡¶º‡¶æ"], ["matches": [["type": "prefix", "scope": "exact", "value": "a"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶Ü"]]],
        ["find": "i`", "replace": "‡¶ø"],
        ["find": "i", "replace": "‡¶ø", "rules": [["matches": [["type": "prefix", "scope": "!consonant"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶á"], ["matches": [["type": "prefix", "scope": "punctuation"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶á"]]],
        ["find": "I`", "replace": "‡ßÄ"],
        ["find": "I", "replace": "‡ßÄ", "rules": [["matches": [["type": "prefix", "scope": "!consonant"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶à"], ["matches": [["type": "prefix", "scope": "punctuation"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶à"]]],
        ["find": "u`", "replace": "‡ßÅ"],
        ["find": "u", "replace": "‡ßÅ", "rules": [["matches": [["type": "prefix", "scope": "!consonant"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶â"], ["matches": [["type": "prefix", "scope": "punctuation"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶â"]]],
        ["find": "U`", "replace": "‡ßÇ"],
        ["find": "U", "replace": "‡ßÇ", "rules": [["matches": [["type": "prefix", "scope": "!consonant"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶ä"], ["matches": [["type": "prefix", "scope": "punctuation"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶ä"]]],
        ["find": "ee`", "replace": "‡ßÄ"],
        ["find": "ee", "replace": "‡ßÄ", "rules": [["matches": [["type": "prefix", "scope": "!consonant"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶à"], ["matches": [["type": "prefix", "scope": "punctuation"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶à"]]],
        ["find": "e`", "replace": "‡ßá"],
        ["find": "e", "replace": "‡ßá", "rules": [["matches": [["type": "prefix", "scope": "!consonant"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶è"], ["matches": [["type": "prefix", "scope": "punctuation"], ["type": "suffix", "scope": "!exact", "value": "`"]], "replace": "‡¶è"]]],
        ["find": "z", "replace": "‡¶Ø"],
        ["find": "Z", "replace": "‡ßç‡¶Ø"],
        ["find": "y", "replace": "‡ßç‡¶Ø", "rules": [["matches": [["type": "prefix", "scope": "!consonant"], ["type": "prefix", "scope": "!punctuation"]], "replace": "‡¶Ø‡¶º"], ["matches": [["type": "prefix", "scope": "punctuation"]], "replace": "‡¶á‡¶Ø‡¶º"]]],
        ["find": "Y", "replace": "‡¶Ø‡¶º"],
        ["find": "q", "replace": "‡¶ï"],
        ["find": "w", "replace": "‡¶ì", "rules": [["matches": [["type": "prefix", "scope": "punctuation"], ["type": "suffix", "scope": "vowel"]], "replace": "‡¶ì‡¶Ø‡¶º"], ["matches": [["type": "prefix", "scope": "consonant"]], "replace": "‡ßç‡¶¨"]]],
        ["find": "x", "replace": "‡¶ï‡ßç‡¶∏", "rules": [["matches": [["type": "prefix", "scope": "punctuation"]], "replace": "‡¶è‡¶ï‡ßç‡¶∏"]]],
        ["find": ":`", "replace": ":"],
        ["find": ":", "replace": "‡¶É"],
        ["find": "^`", "replace": "^"],
        ["find": "^", "replace": "‡¶Å"],
        ["find": ",,", "replace": "‡ßç‚Äå"],
        ["find": ",", "replace": ","],
        ["find": "$", "replace": "‡ß≥"],
        ["find": "`", "replace": ""]
    ]

    let vowel = "aeiou"
    let consonant = "bcdfghjklmnpqrstvwxyz"
    let casesensitive = "oiudgjnrstyz"

    func fixString(_ input: String) -> String {
        var fixed = ""
        for char in input {
            if casesensitive.contains(char.lowercased()) {
                fixed.append(char)
            } else {
                fixed.append(char.lowercased())
            }
        }
        return fixed
    }

    func isVowel(_ c: Character) -> Bool {
        return vowel.contains(c.lowercased())
    }

    func isConsonant(_ c: Character) -> Bool {
        return consonant.contains(c.lowercased())
    }

    func isPunctuation(_ c: Character) -> Bool {
        return !isVowel(c) && !isConsonant(c)
    }

    func isExact(needle: String, haystack: String, start: Int, end: Int, not: Bool) -> Bool {
        guard start >= 0, end <= haystack.count else { return not }
        let substring = String(haystack[haystack.index(haystack.startIndex, offsetBy: start)..<haystack.index(haystack.startIndex, offsetBy: end)])
        return (substring == needle) != not
    }

    func avro(_ text: String) -> String {
        let fixed = fixString(text)
        var output = ""
        var cur = 0
        while cur < fixed.count {
            let start = cur
            var end = cur + 1
            let prev = start - 1
            var matched = false
            for pattern in patterns {
                guard let find = pattern["find"] as? String, let replace = pattern["replace"] as? String else { continue }
                end = cur + find.count
                if end <= fixed.count && String(fixed[fixed.index(fixed.startIndex, offsetBy: start)..<fixed.index(fixed.startIndex, offsetBy: end)]) == find {
                    var ruleMatched = false
                    if let rules = pattern["rules"] as? [[String: Any]] {
                        for rawRule in rules {
                            guard let rule = rawRule as? [String: Any], let replaceRule = rule["replace"] as? String, let matches = rule["matches"] as? [[String: Any]] else { continue }
                            var replaceBool = true
                            for match in matches {
                                guard let type = match["type"] as? String, var scope = match["scope"] as? String else { replaceBool = false; break }
                                var negative = false
                                if scope.first == "!" {
                                    negative = true
                                    scope = String(scope.dropFirst())
                                }
                                let value = match["value"] as? String ?? ""
                                var chk = 0
                                if type == "suffix" {
                                    chk = end
                                } else {
                                    chk = prev
                                }
                                if scope == "punctuation" {
                                    if !((chk < 0 && type == "prefix" || chk >= fixed.count && type == "suffix" || isPunctuation(fixed[fixed.index(fixed.startIndex, offsetBy: chk)])) != negative) {
                                        replaceBool = false; break
                                    }
                                } else if scope == "vowel" {
                                    if !((chk >= 0 && type == "prefix" || chk < fixed.count && type == "suffix") && isVowel(fixed[fixed.index(fixed.startIndex, offsetBy: chk)]) != negative) {
                                        replaceBool = false; break
                                    }
                                } else if scope == "consonant" {
                                    if !((chk >= 0 && type == "prefix" || chk < fixed.count && type == "suffix") && isConsonant(fixed[fixed.index(fixed.startIndex, offsetBy: chk)]) != negative) {
                                        replaceBool = false; break
                                    }
                                } else if scope == "exact" {
                                    let s, e: Int
                                    if type == "suffix" {
                                        s = end
                                        e = end + value.count
                                    } else {
                                        s = start - value.count
                                        e = start
                                    }
                                    if !isExact(needle: value, haystack: fixed, start: s, end: e, not: negative) {
                                        replaceBool = false; break
                                    }
                                }
                            }
                            if replaceBool {
                                output.append(replaceRule)
                                cur = end - 1
                                matched = true
                                ruleMatched = true
                                break
                            }
                        }
                    }
                    if ruleMatched { break }
                    output.append(replace)
                    cur = end - 1
                    matched = true
                    break
                }
            }
            if !matched {
                output.append(fixed[fixed.index(fixed.startIndex, offsetBy: cur)])
            }
            cur += 1
        }
        return output
    }

    func orva(_ text: String) -> String {
        let reversePatterns = patterns.compactMap { pattern -> [String: Any]? in
            guard let replace = pattern["replace"] as? String, let find = pattern["find"] as? String, replace.count > 0, find.count > 0, find != "o", replace != "" else { return nil }
            return ["find": replace, "replace": find, "rules": pattern["rules"] as Any]
        }.sorted { (a, b) in
            guard let findA = a["find"] as? String, let findB = b["find"] as? String else { return false }
            return findA.count > findB.count
        }

        var output = ""
        var cur = 0
        var iterations = 0
        let maxIterations = text.count * 2
        while cur < text.count {
            iterations += 1
            if iterations > maxIterations {
                print("Orva transliteration exceeded maximum iterations, breaking to prevent infinite loop")
                break
            }
            let start = cur
            var matched = false
            for pattern in reversePatterns {
                guard let find = pattern["find"] as? String, let replace = pattern["replace"] as? String else { continue }
                let end = cur + find.count
                if end > text.count { continue }
                let segment = String(text[text.index(text.startIndex, offsetBy: start)..<text.index(text.startIndex, offsetBy: end)])
                if segment == find {
                    output.append(replace)
                    cur = end - 1
                    matched = true
                    break
                }
            }
            if !matched {
                output.append(text[text.index(text.startIndex, offsetBy: cur)])
            }
            cur += 1
        }
        return output.replacingOccurrences(of: "`", with: "").replacingOccurrences(of: "‡¶Ü", with: "a").replacingOccurrences(of: "‡¶Ö", with: "o").replacingOccurrences(of: "‡¶á", with: "i").replacingOccurrences(of: "‡¶à", with: "e").replacingOccurrences(of: "‡¶â", with: "u").replacingOccurrences(of: "‡¶è", with: "e").replacingOccurrences(of: "‡ßç", with: "").replacingOccurrences(of: "‡¶º", with: "").replacingOccurrences(of: "‡¶â", with: "u")
    }

    func banglish(_ text: String) -> String {
        print("Banglish transliteration is not implemented yet")
        return text
    }

    func lishbang(_ text: String) -> String {
        print("Lishbang transliteration is not implemented yet")
        return text
    }

    let modeFunctions: [String: (String) -> String] = [
        "avro": avro,
        "orva": orva,
        "banglish": banglish,
        "lishbang": lishbang
    ]

    guard let fn = modeFunctions[mode] else {
        print("Invalid mode. Available modes are: 'avro', 'orva', 'banglish', 'lishbang'")
        return text
    }
    return fn(text)
}
